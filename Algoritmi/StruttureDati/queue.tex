%Paragrafo sulle code
\section{Code}
La \emph{Queue}, in italiano \emph{coda}, è una struttura dati di tipo FIFO(First in First out) per memorizzare una sequenza di elementi,
in cui l'inserimento di un elemento avviene in coda alla sequenza mentre la rimozione avviene in testa alla sequenza.\newline
Una coda può essere implementata attraverso array oppure delle liste a seconda della scelta implementativa e della capacità di stabilire un limite massimo di elementi utilizzati.

Essendo una coda una particolare tipologia di sequenza può essere implementata facilmente utilizzando una lista e le sue operazioni però,
a differenza dello stack, la scelta della lista utilizzata per l'implementazione cambia il tempo di esecuzione delle operazioni,
infatti soltanto con una lista bidirezionale si ottiene un tempo $\Theta(1)$ in tutte le operazioni per cui noi utilizziamo questa tipologia di lista per implementare una coda.

Le code prevedono la definizione di 3 operazioni:$\proc{isEmpty}$ \ref{alg:isEmpty} indica se la coda contiene o meno degli elementi, $\proc{dequeue()}$ \ref{alg:dequeue}
estrae il primo elemento della coda ed infine si ha $\proc{enqueue(Q, x)}$ \ref{alg:enqueue} che inserisce un elemento nella coda e si assume che $x$ sia un elemento già definito.

%Pseudocodice delle operazioni di una Coda
\begin{codebox}
\Procname{$\proc{isEmpty}()$}
\li \Return ($\attrib{Q}{head} \isequal \const{nil}$)
\end{codebox}
\begin{codebox}
\Procname{$\proc{Enqueue}(Q,x)$}
\li $\attribb{Q}{tail}{next} \gets x$
\li $\attrib{Q}{tail} \gets x$
\end{codebox}
L'esecuzione del metodo $\proc{enqueue}$ richiede $2c$ ossia $\Theta(1)$ per ciò
l'inserimento in una coda richiede un tempo costante.

Il metodo $\proc{dequeue()}$ estra il primo elemento della coda ed è implementato come
\begin{codebox}
\Procname{$\proc{Dequeue}()$}
\li \If $\proc{isEmpty}()$
    \Then
\li           \Return $\const{nil}$
\li $\id{temp} \gets \attrib{Q}{head}{element}$
\li $\attrib{Q}{head} \gets \attribb{Q}{head}{next}$
\li \Return temp
\end{codebox}
L'operazione $\proc{dequeue}$ richede un tempo costante $\Theta(1)$ per effettuare la rimozione.

Tutte le operazioni presentate impiegano tempo costante $\Theta(1)$, cosa che le rende molto efficiente per rappresentare dati cui si vuole una politica FIFO.
%Coda tramite Vettore
Dopo aver visto come viene implementata una coda tramite puntatori, consideriamo l'implementazione tramite un vettore $Q[1 \twodots n]$ 
e ai campi $\attrib{Q}{head}$ e $\attrib{Q}{tail}$ per accedere all'elemento in testa e in coda ai vettore della coda;lo pseudocodice della coda tramite un vettore è il seguente:
\begin{codebox}
\Procname{$\proc{enqueue}(Q,x)$}
\li $Q[\attrib{Q}{tail}] \gets x$
\li \If $\attrib{Q}{tail} \isequal \attrib{Q}{length}$
\li    \Then $\attrib{Q}{tail} \gets 1$
\li \Else $\attrib{Q}{tail} \gets \attrib{Q}{tail} + 1$
\end{codebox}

\begin{codebox}
\Procname{$\proc{dequeue}(Q)$}
\li $x \gets Q[\attrib{Q}{head}]$
\li \If $\attrib{Q}{head} \isequal \attrib{Q}{length}$
\li \Then $\attrib{Q}{head} \gets 1$
\li \Else $\attrib{Q}{head} \gets \attrib{Q}{head} + 1$
\li \Return x
\end{codebox}

\begin{codebox}
\Procname{$\proc{queue-Empty}(Q)$}
\li \Return ($\attrib{Q}{head} \leq 0$)
\end{codebox}

Il tempo di esecuzione delle seguente procedure è sempre costante $\Theta(1)$
come anche la coda tramite sequenza ma ha senso implementare tramite vettore se e soltanto se
si sa determinare il numero degli elementi per evitare uno spreco di memoria.
