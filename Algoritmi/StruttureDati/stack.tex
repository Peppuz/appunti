%Paragrafo sulle stack
\section{Stack}
Lo \emph{stack}, è una struttura dati di tipo \emph{LIFO}(Last in first out), utilizzata
in tutti i linguaggi di programmazione per effettuare la memorizzazione di tutti i dati
di tipo statico e dei record di attivazione, che può essere vista come un caso particolare
di sequenza in cui l'inserimento avviene alla fine della sequenza e la rimozione avviene sempre in fondo.

Uno stack può essere implementato attraverso array oppure delle liste a seconda della
scelta implementatica e della capacità di stabilire un limite massimo di elementi utilizzati.

Essendo lo stack un particolare tipo di sequenza, essa può essere simulata tramite le operazioni di una lista,
in particolare quella singolarmente concatenata, però è prassi comune utilizzare
nomi diversi per indicarne le operazioni per migliore chiarezza.

%specifica operazioni su uno stack
\textbf{void} $\proc{push}(S,x)$ inserisce un elemento in testa allo stack \newline
\textbf{Item*} $\proc{pop}(S)$ rimuove l'elemento in testa allo stack \newline
\textbf{boolean} $\proc{stackEmpty}$ indica se lo stack è vuoto o meno.

%pseudocodice delle operazioni dello stack
Lo pseudocodice delle operazioni di uno stack implementate tramite liste sono:
\begin{codebox}
\Procname{$\proc{push}(S,x)$}
\li $\attrib{x}{next} \gets \attrib{S}{top}$
\li $\attrib{S}{top} \gets x$
\end{codebox}

La procedura $\proc{pop}$ rimuove l'ultimo elemento inserito nello stack e lo ritorna
come valore; in caso lo stack è vuoto genera underflow come errore.
\begin{codebox}
\Procname{$\proc{pop}(S)$}
\li $\id{temp} \gets \attrib{S}{top}$
\li \If $\proc{stackEmpty}(S)$
    \Then
\li        \Error "Underflow"
    \End
\li $\attrib{S}{top} \gets \attribb{S}{top}{next}$
\li \Return $\id{temp}$
\end{codebox}

La procedura $\proc{stackEmpty}$ indica se lo stack è vuoto e viene utilizzato per
assicurarsi di non provare ad accedere allo stack vuoto per la rimozione
\begin{codebox}
\Procname{$\proc{stackEmpty}(S)$}
\li \Return $ \attrib{S}{top} \isequal \const{nil}$
\end{codebox}

Utilizzando le liste per implementare lo stack otteniamo in tutte le operazioni l'
impiego di tempo costante $\Theta(1)$.

L'implementazione dello stack tramite un vettore ha lo stesso impiego di tempo $\Theta(1)$
in tutte le operazioni però per evitare uno spreco di memoria bisogna sapere il numero
di elementi necessari e soprattutto non è possibile superare il numero di elementi massimo
stabilito alla creazione dello stack.

%Pseudocodice delle operazioni dello Stack tramite vettore
La realizzazione delle operazioni dello stack tramite un vettore sono le seguenti:
\begin{codebox}
\Procname{$\proc{push}(S,x)$}
\li $\attrib{S}{top} \gets \attrib{S}{top} + 1$
\li $S[\attrib{S}{top}] \gets x$
\end{codebox}

\begin{codebox}
\Procname{$\proc{pop}(S)$}
\li \If $\proc{stackEmpty}(S)$
\li \Then \Error "Underflow"
\li \Else $\attrib{S}{top} \gets \attrib{S}{top}-1$
\li \Return $S[\attrib{S}{top}+1]$
\end{codebox}

\begin{codebox}
\Procname{$\proc{stackEmpty}(S)$}
\li \Return $\attrib{S}{top} \leq 0$
\end{codebox}

Un famoso esempio di utilizzo dello stack è quello di valutare delle espressioni
algebriche scritte in input tramite stringhe come cercheremo di fare ora:
