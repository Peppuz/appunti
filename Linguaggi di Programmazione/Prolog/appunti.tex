\documentclass[a4paper]{book}
\usepackage[T1]{fontenc}%per rappresentare i font italiani, come le lettere accentate, con la giusta spaziatura
\usepackage[utf8]{inputenc}%per poter inserire nel testo .tex i caratteri unicode8
\usepackage[italian]{babel}%per poter effettuare la giusta sillabazione della lingua italiana
\usepackage{classicthesis}%necessario per utilizzare lo stile dell'Ars Classica
\usepackage{arsclassica}% per avere lo stile dell'Arte di imparare il latex
\usepackage{amsmath}%per poter rappresentare ed utilizzare al meglio gli ambienti e le formule matematiche
\usepackage{amssymb}%per rappresentare alcuni simboli particolari matematici
\usepackage{amsthm}%per definire e poter effettuare le dimostrazioni matematiche
%\usepackage{amsfont}%per poter avere i font matematici
\usepackage{booktabs}%per la corretta gestione delle tabelle
\usepackage{graphics}%per effettuare i grafici
\usepackage{pgfplots}%per i grafici
\usepackage{rotating}%per effettuare le rotazioni delle immagini e grafici
\usepackage{microtype}%per effettuare un aggiustamento della spaziatura tra caratteri e del font
\usepackage[cache = false]{minted}
\usepackage{color}
\usepackage{framed}
\usepackage{listings}
\usepackage{url}%per poter rappresentare gli url nel testo latex
%\usepackage{hypertext}%per effettuare un collegamento con una pagina internet
\newtheorem*{defi}{Defi}%Definizione per avere la gestione delle definizioni
\newtheorem*{teorema}{Th}
\newtheorem*{esempio}{Esempio}
\definecolor{shadecolor}{gray}{0.90}

\begin{document}
%Intestazione e indice dei contenuti
\title{Linguaggi di Programmazione}
\author{Marco Natali}
\date{}%rappresenta la data di compilazione del file
\maketitle

\tableofcontents

\chapter{Introduzione ai Paradigmi di Programmazione}
Nel corso di Linguaggi di Programmazione ci occupiamo di 3 importanti paradigmi di
linguaggi quali i linguaggi logici, linguaggi funzionali e linguaggi predicativi, la cui conoscenza è importante
per decidere quale paradigma usare per risolvere un particolare problema e permette di migliorare la
propria competenza nell'ambito della programmazione per scrivere programmi il più possibile efficienti.

Durante il corso, ma soprattutto durante la vita futura lavorativa, si dovrebbero rispettare le regole
standard di rappresentazione e formattazione dei programmi quali ad esempio lo standard Google, regole GNU, per cui nei programmi
sviluppati in questo corso devono rispettare le seguenti convenzioni:
\begin{itemize}
\item ``Usare Emacs come editor in quanto indenta lui al meglio'' cit Antoniotti
\item le linee di codice non devono essere più lunghe di 80 colonne per riga
\item inserire spazi tra gli operatori e uno spazio dopo virgola  e punto e virgola  ossia \textbf{2 + 3} e \textbf{(4, 5)}.
\item non inserire uno spazio tra il nome di una funzione/predicato e le parentesi ossia \textbf{foo(4)}.
\item inserire uno spazio tra un istruzione di controllo/operatori logici e le parentesi ossia \textbf{if (4 || 5)}
\item non usare i commenti all'interno di un box perchè difficilmente mantenibile
\end{itemize}
I linguaggi di programmazione vengono classificati in base a quale paradigma implementano per la computazione, ossia il modello di riferimento
usato per strutturare un programma, al fine di facilitare l'apprendimento di linguaggi similari:
\begin{itemize}
\item \textbf{Imperative Languages}: basati sull'architettura di Von Neumann, utilizzata da tutti i calcolatori moderni,
      in cui il processore ha il compito di leggere e scrivere le celle di memoria durante l'esecuzione della computazione.\newline
      Questo paradigma utilizza uno stile prescrittivo, ossia i programmi iterativi specificano una sequenza
      di istruzioni da eseguire per modificare lo stato del sistema e questo flusso può essere modificato soltanto con
      le strutture di controllo.\newline
      Ne fanno parte il C/C++, i linguaggi Assembler, Pascal, Python, \dots
\item \textbf{Logic Languages}: paradigma in cui un programma è una deduzione logica, ossia ogni istruzione è una formula del linguaggio
  e la computazione consiste nell'interrogare il sistema per sapere se l'interrogazione fa parte della conoscenza rappresentata dal programma.

      Questo paradigma viene utilizzato principalmente per la dimostrazione della correttezza di un programma, per rappresentare i database
      ed infine sta avendo un notevole utilizzo ultimamente nel campo dell'AI(Artificial Intelligence).\newline
      Fa parte di questo paradigma principalmente solo il Prolog e i suoi derivati, infatti noi useremo il SWI-Prolog.
\item \textbf{Functional Languages}: paradigma in cui il concetto di funzione è l'unica cosa importante infatti i programmi
      consistono nell'applicazione e nella definizione di una serie di funzioni.\newline
      Ne fanno parte i linguaggi Lisp, Common Lisp, Scheme, Javascript, ML, Ocaml, Haskell, R e pochi altri.
\end{itemize}
Ognuno dei seguenti paradigmi può essere ad oggetti, come ad esempio Java, C++, Common Lisp, Python,
infatti il paradigma ad oggetti è ortogonale alla definizione data da noi delle diverse tipologie dei linguaggi,
anche se presume alcune caratteristiche tipiche dei linguaggi imperativi.

\section{Paradigma Imperativo}
Il paradigma imperativo, come già visto, si occupa di eseguire una sequenza di istruzioni
infatti fu inventato per la computazione ``numerica'', a differenza degli altri paradigmi che si concentrano sulla computazione simbolica.

Un programma imperativo è composto da due componenti, uno per rappresentare le strutture dati e l'altro per gli algoritmi:
\begin{itemize}
\item dichiarazione in cui vengono dichiarate le variabili, i tipi e le funzioni necessarie per la computazione,
      ossia vengono stabilite le strutture dati necessarie per l'implementazione del programma.
\item definizione in cui si implementatno gli algoritmi, per eseguire correttamente la computazione, utilizzando le istruzioni del linguaggio.
\end{itemize}
Il paradigma imperativo ha spopolato fino agli anni '70/80 quando venne spodestato dal paradigma ad Oggetti e noi lo abbiamo già
affrontato durante il corso Programmazione per cui in sto corso vedremo soltanto alcune peculiarità del linguaggio C,
come ad esempio la gestione manuale della memoria.
%Inserire esempio di Programma Imperativo

La necessità di usare le applicazione ad un maggiore livello di astrazione e di scrivere programmi il più concisi possibile, ha spinto
alla creazione di nuovi paradigmi, come quello logico che analizzeremo ora.

\section{Paradigma Logico}
Il paradigma logico non è più basato sull'architettura di Von Neumann ma sulla logica matematica, anche se quando viene implementato sui
calcolatori alcune caratteristiche sono derivate dal paradigma imperativo, ed utilizza uno stile di programmazione descrittivo,
ossia viene definito cosa fa parte del problema da rappresentare.

Inoltre nella programmazione logica non è presente alcuna separazione netta tra gli algoritmi e le strutture dati e, come già
visto nella definizione dei vari paradigmi, un programma consiste nel descrivere un problema come una serie di sentenze del linguaggio
ed interrogare il sistema, il quale effettua una deduzione sulla base della conoscenza rappresentata.

Un esempio di programma logico è il seguente:
\inputminted{prolog}{esempi/employees.pl}
Questo programma implementa la regolazione di lavorare per una compagnia e se due persone sono colleghi, anche se una trattazione
completa della semantica verrà fornita nei successivi paragrafi.
\section{Paradigma Funzionale}
Il paradigma funzionale, come già notato nel paradigma logico, viene usato per una programmazione simbolica,
in cui si adotta solitamente uno stile descrittivo ed infine non vi è una completa separazione tra strutture dati ed algoritmi.

Il concetto fondamentale di questo paradigma è la funzione, relazione definita su due insiemi che associa ad un elemento del dominio uno e
un solo elemento del codominio.

Dopo che sono state definite le funzioni necessarie per la computazione, possiamo applicarle sugli elementi del dominio
per ottenere un valutazione delle funzioni e ciò è cosa si definisce per computazione nel paradigma funzionale.\newline
In un linguaggio funzionale puro la valutazione viene determinata soltanto dalla funzione e non da i valori in memoria e
ciò permette di definire una variabile come una costante matematica, in cui il valore non è mutabile,
cosa differente rispetto alle variabili nei linguaggi imperativi che sono una astrazione di una locazione in memoria.

Esempio di programma funzionale:

\section{Richiami sugli ambienti RunTime}
Per eseguire un programma in un qualsiasi linguaggio il sistema operativo deve mettere a disposizione
un ambiente \textit{run time}, anche una macchina virtuale, il quale fornisce almeno due funzionalità:
\begin{itemize}
\item mantenimento dello stato della computazione attraverso program counter, limiti di memoria ed etc\dots
\item gestione della memoria disponibile, fisica e virtuale, il quale avviene usando due aree distinte con funzioni diverse:
      \begin{itemize}
      \item lo \textbf{Stack}  serve per la gestione delle chiamate, soprattutto ricorsive, a procedure attraverso i record di attivazione.
      \item lo \textbf{Heap} serve per la gestione di strutture dati dinamiche, quali liste, alberi, dizionari ed etc \dots
      \end{itemize}
\end{itemize}
I linguaggi logici e funzionali (ma anche Java) utilizzano pesantemente lo Heap dato che forniscono come strutture dati built-in
liste e spesso vettori di dimensione variabile.

La gestione dei record di attivazione è stata affrontata nei corsi di Programmazione ed Architettura, a cui si può consultare
libri e gli appunti per rinfrescarne la memoria.

La gestione della memoria, in particolare quella dinamica, può avvenire in maniera automatica, attraverso il \emph{Garbage Collector}
usato da Python, Java, Lisp, Prolog ed altri, oppure in maniera manuale, come in C/C++ attraverso i comandi malloc(new) e free(delete).
%Inserire esempi

\input{logica.tex}%Capitolo sulla logica matematica
\input{prolog.tex}%Capitolo sulla programmazione logica in Prolog

\chapter{Lisp:Programmazione Funzionale}
Dopo aver affrontato ed analizzato il Prolog e il paradigma Logico, è arrivato
il momento di analizzare il paradigma ``matematico'' funzionale,
in cui la computazione risiede nel definire e applicare una serie di funzioni,
anche composte e soprattutto ricorsive.\newline
Nel paradigma funzionale risulta verificato il concetto matematico della \textbf{trasparenza refenziale},
funzione senza effetti collaterali che quando riceve lo stesso parametro in input,
restituisce sempre lo stesso valore, cosa non sempre verificata negli altri linguaggi.

L'uso della trasparenza referenziale ha il grande vantaggio di permettere al programmatore
di poter contare su un comportamento univoco delle funzioni, a priori non sempre prevedibili
e ciò aiuta molto nel processo di testing e debug, semplifica l'implementazione di algoritmi,
rende più facili la modifica e l'ottimizzazione dei programmi senza cambiarne radicalmente la struttura.

Nel paradigma funzionale vi sono oggetti di vario tipo e strutture di controllo, ma vengono raggruppati logicamente in modo diverso
da come invece accade nel paradigma imperativo, infatti risulta utile pensare in termini di:
\begin{itemize}
\item espressioni, il quale rappresenta i fondamenti del linguaggio come le funzioni semplici e primitive.
\item modi di combinare le espressioni per ottenerne di più complesse, tramite l'operazione di composizione
\item modi e metodi di costruzione ``astratte''  per poter far riferimento a gruppi di espressioni per “nome” e per trattarle come unità separate
\item operatori speciali (condizionali ed altri ancora, che verranno introdotti in seguito)
\end{itemize}

Noi affronteremo come esempio di linguaggio funzionale, il linguaggio Common Lisp, una dei principali dialetti, come anche lo Scheme, della famiglia
di linguaggi chiamati Lisp.\newline
Lo studio del Lisp, anche se in una delle sue incarnazioni, è importante dato che è il primo linguaggio di programmazione funzionale e
le sue versioni minimali ammettono:
\begin{itemize}
\item funzioni primitive su \textbf{liste}
\item un'operatore speciale \textbf{lambda} per creare funzioni
\item un'operatore codizionale \textbf{cond}
\item un piccolo insieme di predicati ed operatori speciali
\end{itemize}

Incominciamo a mostrare come valuta e computa le espressione il Common Lisp
e la prima cosa notata è che ogni ``espressione'' denota un valore.
\begin{minted}{Lisp}
prompt> 42
42

prompt> ”Sapete che cos’e` ’42’?”
”Sapete che cos’e` ’42’?”
\end{minted}
In Lisp sono presenti le operazioni aritmetiche principali(+ - * /), rappresentate in notazione prefissa,
il quale permettono di essere applicate a più argomenti ed evitano di generare ambiguità su quale operazione viene
applicata in caso di più operazioni, come si nota nei seguenti esempi:
\begin{minted}{Lisp}
  prompt> (+ 137 349)
  486

  prompt> (- 1000 334)
  666

  prompt> (+ 2.7 10)
  12.7

  prompt> (* 2 34)
  68

  prompt> (/ 10 5)
  2
\end{minted}
Queste espressioni, formate delimitanto una lista di espressioni all'interno di parentesi per mostrare l'applicazione di una funzione,
sono chiamate \emph{combinazioni} e il valore viene determinato applicando la procedura, specificata dall'operatore, agli argomenti,
i quali sono i valori degli operandi.
Le espressioni possono essere annidate, per cui per motivi di lettura si allineano gli argomenti di chiamata verticalmente, come nell'esempio:
\begin{minted}{Lisp}
prompt> (+ (* 3
              (+ (* 2 4)
                 (+ 3 2)))
           (+ (- 10 8)
              1))
42
\end{minted}
Notiamo come le funzioni aritmetiche elementari + e * in (Common) LISP rispettano i vincoli di “campo” algebrico:
\begin{minted}{Lisp}
prompt> (+)
0

prompt> (*)
1
\end{minted}
Un aspetto dei linguaggi di programmazione è quello di fornire dei nomi, per riferirsi agli oggetti computazionali,
ed ovviamente anche nel Common Lisp ciò avviene tramite l'istruzione $defparameter$, che si comporta nel seguente modo:
\begin{minted}{Lisp}
  (defparameter pi_greco 3.14)
  (defparameter size 2)
\end{minted}
Per valutare una espressione combinata, l'interprete Lisp esegue le seugenti operazioni:
\begin{enumerate}
\item viene valutata la sottoespressione, presente nella combinazione
\item viene applicata la procedura, rappresentata dalla sottoespressione left-most, agli argomenti
  rappresentati dai valori delle altre sottoespressioni.
\end{enumerate}
Ovviamente come si può notare la valutazione risulta ricorsiva e i componenti basilari, su cui si riesce ad effettuare correttamente la valutazione
sono i seguenti:
\begin{itemize}
\item il valore dei numeri sono ovviamente il numero stesso
\item il valore degli operatori built-in sono le istruzioni macchina che corrispondono a quell'operatore.
\item il valore degli altri nomi sono gli oggetti associati a quel nome nell'ambiente definito nel programma Lisp
\end{itemize}
Questo concetto per valutare le espressioni non si applica agli operatori speciali, come ad esempio defparameter.

In Lisp si hanno come dati e procedure predefinite il seguente elenco di elementi:
\begin{itemize}
\item numeri interi, numeri in virgola mobile (es. $3.5$ o $6.02E+21$), numeri razionali
      (es. $-3/42$) o numeri complessi ($\#C (0 1)$)
\item booleani $T$ e $NIL$
\item stringhe (es $"sono\,\,\, una \,\,\,stringa"$)
\item operatiori sui booleani $null,\,\,\,and,\,\,\, or,\,\,\,not$
\item funzioni sui numeri \textit{+ - / * mod sin cos sqrt tan atan plusp > <= zerop}
\end{itemize}
Per definire nuove funzioni, per fornire una forma di astrattezza e fornire il nome ad una serie di operazione,
in Lisp si usa il comando \mint{Lisp}|defun (nome (argomenti) (corpo funzione))|:
Ovviamente questa possibilità di definire nuove funzioni può essere combinato per creare
in maniera semplice nuove funzioni, come si può notare nel listato di esempio:
\begin{figure}
\caption{Esempi di definizioni di funzioni}
\begin{minted}{Lisp}
prompt> (defun square (x) (* x x))
square

prompt> (square 5)
25

prompt> (defun sum-of-square(x, y) (+ (square x) (square y)))
sum-of-square

prompt> (sum-of-square 3 4)
25
\end{minted}
\end{figure}
La definizione di nuove funzioni permette di creare un'astrazione e considerare la procedura come una ``black box'', in cui l'utilizzatore
della funzione può essere diverso da chi l'ha definita e la utilizza senza sapere i dettagli implementativi; ciò permette di poter cambiare
l'implementazione senza preoccuparsi di dover cambiare tutti i riferimenti ad essa e di avere i parametri a visibilità locale alla procedura.

Per valutare una espressione combinata dove un operatore indica una funzione composta, definita tramite \emph{defun}, l'interprete Lisp segue
lo stesso processo visto per valutare le funzioni/operazioni primitive, infatti l'interprete valutano gli elementi presenti nell'espressioni
e poi applicano la procedura agli argomenti, indicati dagli operandi nell'espressione.\newline
Per applicare una funzione composta agli argomenti si valuta il corpo della procedura in cui ogni parametro formale
viene sostituito dall'argomento corrispondente e per illustrare il processo vediamo come viene valutata la seguente espressione
!!!inserire esempio di applicazione di un'espressione

Il processo descritto e mostrato nel seguente esempio viene chiamato \textbf{substitution model} e lo scopo di questo processo è quello
di aiutare a pensare a come si applica alla procedura, ma non fornisce una descrizione fedele di come un interprete realmente lavora.

Inserire differenza tra applicazione e ordine normale


La potenza espressiva delle funzioni definite fino ad ora è limitata, dato che non abbiamo ancora la possibilità di effettuare delle scelte
e per risolvere introduciamo ora il costrutto speciale \textbf{cond}$(cond\,\,(p_1\,\,e_1),\,\,...\,\,(p_n\,\,e_n))$:
consiste in una coppia di espressioni, dove il primo elemento è sempre un predicato ``logico'', come si può notare nel listato di esempio.\newline
L'operatore cond verifica ogni coppia di espressioni e se il risultato è T ritorna il valore della seconda espressione altrimenti
passa alla coppia successiva fino a che se non ci sono più coppie valutabili restituisce NIL.\newline
In aggiunta ai predicati aritmetici, < > =, per effettuare dei confronti si possono utilizzare i predicati \textbf{and, or, not},
definiti come si nota nel seguente listato:
\begin{figure}
\begin{minted}{lisp}
prompt> (and (> 42 0) (< -42 0))
T

prompt> (not (> 42 0))
NIL

prompt> (and)
T

prompt> (or)
NIL
\end{minted}
\end{figure}

\begin{figure}
\begin{minted}{lisp}
(defun valore-assoluto (x)
   (cond ((> x 0) x)
         ((= x 0) 0)
         ((< x 0) (- x))))

prompt> (valore-assoluto 3)
3

prompt> (valore-assoluto -42)
42
\end{minted}
\end{figure}
Per rappresentare il valore assoluto, come si vede nel listato Y, si poteva utilizzare anche il predicato \mint{Lisp}
|(if <predicate> <conseguent> <alternative>)|, applicabile quando si hanno solo due casi da analizzare.\newline
Per valutare il predicato \emph{if} l'interprete inizia a valutare la parte <predicate> dell'espressione: in caso viene valutata con $T$
allora l'interprete valuta la parte <conseguent> e ritornaa il suo valore, altrimenti viene valutato la parte <alternative> e ritorna il suo valore.

\begin{figure}
\begin{minted}{lisp}
prompt> (define (abs x)
            (if (< x 0)
            (-x)
             x))
\end{minted}
\end{figure}
Nella definizione di una funzione è possibile che si abbia la necessità di usare delle funzioni ausiliarie, che può avvenire in maniera separata
oppure in maniera innestata, attraverso una definizione \emph{block structure}, il quale permette di isolare e non fornire ad altre funzioni
la procedura ausiliaria.\newline
La scelta tra i due modi dipende dal fatto se la procedura ausiliaria può essere usata all'in fuori della procedura oppure dipende sempre da essa:
nel primo caso si usa una definizione separata per poter usare da sola mentre nel secondo caso si utilizza una definizione innestata.

Vediamo una funzione ricoriva come il fattoriale:
\begin{minted}{lisp}
(defun fattoriale (n)
    (if (= n 0)
        1
        (* n (fattoriale (- n 1)))))
\end{minted}
Questa funzione calcola il fattoriale di un numero utilizzando una sequenza di valori intermedi che devono essere salvati sullo ``stack''
di attivazione di ogni chiamata ricorsiva e questa definizione matematica e ricorsiva del fattoriale richiede $\Theta(n)$ sia in tempo che spazio
per effettuare il fattoriale di un numero $n$ ma utilizzando una procedura iterativa, in cui ad ogni passo teniamo traccia del fattoriale
calcolato al passato, richiedendo uno spazio $\Theta(1)$ per effettuare la computazione, come si può nuotare nel seguente listato:
\begin{figure}
  \includeminted{Esempi/fattorialeRicorsivo.lisp}{Lisp}
\end{figure}
Con la procedura ausiliaria innestata  si ha la presenza sia di un ``ciclo in incognito'' non visibile all'esterno, che permette al compilatore di
ottimizzare, attraversola chiamata di una jump, e questa procedura ausiliaria viene detta \textbf{tail-recursive}.

Vediamo anche Fibonacci:
\begin{minted}{lisp}
(defun fib (n)
     (cond ((= n 0) 1)
           ((= n 1) 1)
           (T (+ (fib (- n 2)) (fib (- n 1))))
            ))
\end{minted}
In Lisp, come tutti i linguaggi funzionali essendo basati sul lambda-calcolo di Church,
si possono definire funzioni anonime, chiamate \textbf{funzioni lambda}, utili per
definire funzioni ausiliarie senza fornigli un nome ed un'esempio viene fornito dal listato:
\begin{figure}
\begin{minted}{Lisp}
       (lambda (x y) (* x y))
\end{minted}
\end{figure}
Le funzioni lambda forniscono una certa eleganza al codice e permettono di non associare
il nome a delle procedure ausiliarie, il cui utilizzo necessità di una procedura principale.
Usando l'operatore lambda possiamo costruire una serie di valori intermedi da
utilizzare per la computazione e questo utilizzo è talmente standard ed utilizzato
che il Lisp ha fornito l'operatore speciale \textbf{let}, per cui i seguenti listati
sono equivalenti:
LISTATO LAMBDA

LISTATO LET
IMPLEMENTAZIONE ITERATIVA DEL FIBONACCI
\section{Strutture Dati in Lisp}
Nei precedenti paragrafi abbiamo assunto e definito solo espressioni e funzioni che operano su numeri mentre i programmi sono solitamente
definiti su dati composti, al fine di rappresentare al meglio la realtà e di elevare il livello concettuale dei nostri programmi, permettendo
di avere una maggiore potenza espressiva del linguaggio.

Per vedere l'importanza e come definire un dato composto consideriamo ora la costruzione di una libreria per fare lavorare coi numeri razionali
ed innanzitutto assumiamo di aver a disposizione una funzione che costruisce una rappresentazione di un numero razionale:
\begin{minted}{lisp}
(make-rat n d) Þ <il razionale n/d>
\end{minted}
Assumiamo anche di avere due funzioni numer and denom che straggono rispettivamente il numeratore n ed il denominatore dalla
rappresentazione di un numero razionale <razionale n/d>:
\begin{minted}{lisp}
(defun somma-raz (r1 r2)
    (crea-razionale (+ (* (numer r1) (denom r2))
                       (* (numer r2) (denom r1)))
                    (* (denom r1) (denom r2))))
(defun molt-raz (r1 r2)
    (crea-razionale (* (numer r1) (numer r2))
                    (* (denom r1) (denom r2)))
(defun =-raz (r1 r2)
    (= (* (numer r1) (denom r2))
       (* (numer r2) (denom r1))))

...
\end{minted}
Questa definizione dei numeri razionali permettono di aumentare la modularità dei nostri programmi e di poter manipolare i numeri razionali,
senza conoscere come sono stati definiti.

Una delle strutture più importanti del Lisp è la \textbf{Cons-Cell}, ovvero una coppia di due elementi a cui si può accedere tramite
\textit{car e cdr}, il quale puntano al primo e secondo elemento, come si nota nel seguente listato di esempio:
\begin{figure}
\begin{minted}{Lisp}
prompt> (defparameter c (cons 40 2))
c

prompt> (car c)
40

prompt> (cdr c)
2
\end{minted}
\end{figure}
Una coppia è un oggetto a cui si può dare un nome e manipolare, come gli oggetti primitivi, e ciò permette di creare coppie annidate come si nota:
\begin{figure}
\begin{minted}{Lisp}
  prompt> (defparameter x (cons 1 2))
  x

  prompt> (defparameter y (cons 3 4))
  y

  prompt> (defparameter z (cons x y))
  z

  prompt> (car (car z))
  1

  prompt> (car (cdr z))
  3
\end{minted}
\end{figure}
La definizione delle coppie ci semplifica la libreria per i razionali, infatti definiamo un numero razionale tramite la seguente definizione:
con questo costrutto si semplifica la libreria per i razionali:
\begin{figure}
\begin{minted}{lisp}
(defun make-rat (n d)
                (cons n d))%rappresenta il costruttore

(defun numer (r) (car r))%rappresenta il selettore

(defun denom (r) (cdr r))%rappresenta il selettore

prompt> (denom (make-rat 42 7))
7
\end{minted}
\end{figure}

La funzione cons genera in memoria dei grafi di puntatori arbitrariamente complessi, rappresentati in una tradizionale notazione
detta \textit{box-and-pointer}:
\begin{figure}
\centering
\includegraphics[scale=0.7]{img/cons.png}
\end{figure}
Posso inserire anche T e NIL (rappresentato da una sbarra):
\begin{figure}
\includegraphics[scale=0.7]{img/cons2.png}
\end{figure}
Vediamo qualche esempio:
\begin{figure}
\begin{minted}{Lisp}
prompt> (cons NIL T)
(NIL . T) ; Notazione “dotted-pair”
          ; (“coppia-puntata”). Gli spazi
          ; sono significativi.

prompt> (cons 4 2)
(4 . 2)
\end{minted}
\end{figure}
Un altra utile struttura dati, definibile attraverso l'uso delle pairs, è la lista, sequenza ordinata di oggetti, rappresentabile in varie maniera
ma la più immediata consiste una serie di pair, dove la car di ogni pair rappresenta un elemento mentre la cdr è un riferimento
al prossimo elemento della lista che può essere NIL.\newline
La definizione della sequenza $(1, 2, 3, 4)$ in Common Lisp viene definito nel seguente listato:
\begin{figure}
\begin{minted}{Lisp}
  (defparameter L (cons 1 (cons 2 (cons 3 (cons 4)))))
\end{minted}
\end{figure}

\begin{center}
  \includegraphics[scale=0.7]{img/cons3.png}
\end{center}
Una lista Lisp corrispondente a questa configurazione di cons-cells viene rappresentata tipograficamente come \textit{((T) 42)} che è equivalente
a \textit{((T . NIL) . (42 . NIL))}.\newline
Quindi una cons-cell con NIL come secondo elemento (ovvero come cdr) viene stampata senza il punto ed il NIL:
\begin{minted}{Lisp}
prompt> (cons 42 nil)
(42)

prompt> (cons ”foo bar” nil)
(”foo bar”)
\end{minted}

\begin{figure}
\begin{minted}{lisp}
  (defparameter L (list 1 2 3 4))

  prompt> (car (cdr (cdr L)))
  3
\end{minted}
\end{figure}
L'implementazione delle operazioni standard definite sulle liste si può notare
nel listato di esempio:
INSERIRE LISTATO SULLE liste

La definizione di funzioni ricorsive sulle liste può essere semplice, in caso si
effettuano le chiamate ricorsive solo sulla coda, oppure doppia in caso si lavora
sia sulla testa che sulla coda della lista.%Inserire esempi

Per estrarre un elemento di una lista si utilizza la funzione standard \textbf{nth}
ed inoltre la funzione \textbf{cdr} ritorna il "resto" di una lista, come fatto
anche dalla funzione \textbf{rest}.\newline
Per ottenere il primo elemento di una lista si può usare la funzione \textbf{car}
oppure la funzione standard \textbf{first}.

Se si volesse definire in Lisp una lista del tipo $(A B C D)$, per quello che
abbiamo visto fino ad ora, non sarebbe possibile dato che l'interprete Lisp con l'espressione
                     cercherebbe di valutare la funzione list, applicata ai simboli $A, B, C, D$
ma ciò causa un errore, non essendo i simboli associati a qualche valore nell'ambiente,
come si nota nel listato di seguito:
\begin{figure}
\begin{minted}{Lisp}
prompt> (list A B C D)
ERRORE A NON HA NESSUN VALORE ASSOCIATO

prompt> (list 'A 'B 'C 'D)
(A B C D)
\end{minted}
\end{figure}
Per poter gestire i dati simbolici, come ad esempio la lista $(A B C D)$ oppure
$(+ quaranta 2)$ senza procedere alla valutazione delle espressioni, si ha la funzione
$quote <e>$, rappresentabile anche con $'<e>$;
la funzione quote sui numeri e stringhe è inutile dato che la loro valutazione è
identica alla rappresentazione data mentre serve per rappresentare i dati simbolici,
come le espressioni composte e/o rappresentazione di una sequenza di elementi,
come si nota nel listato ADD:
\begin{figure}
\begin{minted}
prompt> '42
42

prompt> '"la gatta ha fretta"
la gatta ha fretta

prompt> (list 'A 'B)
(A B)

prompt> '(defun media (x y) (/ (+ x y) 2.0))
(DEFUN MEDIA (X Y) (/ (+ X Y) 2.0))
\end{minted}
\end{figure}
FARE LA VALUTAZIONE DELLA FUNZIONE EVAL

In Lisp per controllare se due oggetti sono uguali vengono forniti una molteplicità
di funzioni built-in ma le principali sono le seguenti:
\begin{description}
  \item [eql:] viene usato per controllare l'uguagianza di simboli, numeri interi e stringhe
  \item [equal:] è in grado anche di controllare se due liste sono uguali e questa funzione
         non fa altro che applcare eql ricorsivamente a tutti gli atomi della lista.
\end{description}

\section{Funzioni di ordine superiore}
Dopo aver analizzato come si definiscono le liste, le funzioni e come essere in grado
in modo simbolico i dati, grazie all'operatore speciale quote, possiamo considerare
gli aspetti e  della programmazione funzionale.

Incominciamo delle funzioni di ordine superiore, il quale sono delle funzioni che
prendono uno o più funzioni come argomenti e possono ritornare anche una funzione.

Questa possibilità rappresenta il cuore e l'essenza della programmazione funzionale
e le principali funzioni standard di ordine superiore sono le seguenti:
\begin{description}
  \item [mapcar:] rappresenta l'astrazione di applicare la funzione f a tutti gli
         elementi della lista L e ritorna una lista di valori.
         Può essere definita, anche se è già built-in, nel seguente modo:
         \begin{minted}{Lisp}
              (defun mapcar (funzione lista)
                     (if (null lista)
                          null
                          (cons (funcall funzione (car lista))
                                 (mapcar funzione (cdr lista)))))
         \end{minted}
  \item [compose:] rappresenta la composizione di funzioni, ossia date due funzioni
                   $f$ e $g$, di un solo parametro, come argomenti viene ritornata
                   una nuova funzione corrispondente a $f(g(x))$.\newline
                   Può essere definita nel seguente modo:
                   \begin{minted}{Lisp}
                   (defun compose (f g)
                          (lambda (x)
                                  (funcall f (funcall g x))))
                   \end{minted}
  \item [filter:] rimuove gli elementi della lista che non soddisfano il predicato
                 e può essere definito nella seguente maniera:
                 \begin{minted}{Lisp}
                 (defun filter (predicato lista)
                        (cond ((null lista) nil)
                              ((funcall predicato (car lista))
                               (cons (car lista)
                                     (filter predicato (cdr lista)))
                              (T (filter predicato (cdr lista))))))
                 \end{minted}
  \item [accumula:] applica una funzione ad un elemento di una lista e il risultato
                    dell'applicazione ricorsiva di accumula al resto della lista;
                    la definizione di questa funzione potrebbe essere la seguente:
                    \begin{minted}{Lisp}
                    (defun accumula (f iniziale lista)
                           (if (null lista)
                               iniziale
                               (funcall f (car lista)
                                        (accumula f iniziale (cdr lista)))))
                    \end{minted}
\end{description}
In common Lisp alcuni simboli hanno un interpretazione particolare, per esempio
i simboli iniziati con : vengono detti \textbf{keywords} ed hanno come valore se stesso,
come si può notare nel listato XXTTT.
\begin{esempio}
  \begin{minted}{Lisp}
  cl-prompt> :foo
  :foo

  cl-prompt> :forty-two
  :forty-two
\end{minted}
\end{esempio}
Le keywords vengono utilizzate in maniera estesa in Common Lisp e servono essenzialmente
per definire delle funzioni con una sintassi di chiamata più utile ed interessante,
ma prima di parlarne vediamo ora le sequenze variabili di argomenti, chiamate \textbf{lambda list}.

In Common Lisp è possibile definire delle funzioni che prendono un numero variabile di argomenti,
come si può notare nel listato CCCCCC, utile per permettere l'applicazione della funzione
a più argomenti possibili.\newline
È disponibile anche definire delle funzioni con dei parametri opzionali, infatti basta
usare la sintassi utilizzata nel listato ffsdafdfd, che possono essere inizializzati
con un valore di default.

In Common Lisp si possono definire delle funzioni che utilizzano i loro parametri
associandoli alle keyword e ciò è molto comune infatti molte funzioni standard
hanno questo comportamento, come si nota nel listato di esempio XXXXXX.

Ovviamente si possono definire delle funzioni che accettano parametri keywords, ovvero
ogni parametro passato in questa maniera diventa una keyword da poter utilizzare
al momento della chiamata della funzione, come si nota nel listato XXXXXXXX.

Questi parametri opzionali, a chiave e variabili devono essere sempre dichiarati
dopo i parametri obbligatori e il loro utilizzo è molto pervasivo in Common Lisp,
anche se noi non abbiamo visto le regole più sofisticate per il loro utilizzo.


\section{Input ed Output}
Dopo aver analizzato il paradigma funzionale e la sua essenza, ci concentriamo ora
sulla gestione dell'input ed output in Common Lisp: le due funzioni principali per
questo scopo sono \textbf{read} e \textbf{print}.

La funzione READ legge un intero oggetto Lisp, riconoscendone la sintassi, come
si può notare nel listato fsffsfsfsdsdfa, mentre la funzione PRINT stampa un oggetto
Lisp rispettandone la sintassi e il valore ritornato è il valore dell'oggetto la
cui rappresentazione è appena stata stampata, come si nota nel listato DDFGGGG.

Ovviamente queste funzioni sono molto grezze per cui è bene avere a disposizione
dei metodi per poter stampare in maniera più agevole, per questa maniera il Common Lisp
mette a disposizione la funzione molto complessa FORMAT(simile alla fprintf in C/C++).







Il linguaggio Lisp mette a disposizione una linea di comando interattiva, il quale
effettua il ciclo \textbf{READ-EVAL-PRINT}:
\begin{enumerate}
  \item READ: legge l'espressione inserita e viene rappresentata internamente in
        strutture dati appropriate(numeri, caratteri, simboli, stringhe ed ecc...)
  \item EVAL: viene valutata l'espressione inserita e dato che programmi e sexp's
        in Lisp sono equivalenti possiamo dare le seguenti regole di valutazione:
        \begin{itemize}
          \item Se una sexp's è un atomo ritorna il suo valore se è una stringa o un numero,
                in caso sia un simbolo viene estratto il suo valore corrente e viene ritornato
                invece se non esiste un valore associato al simbolo viene segnalato un errore.
          \item Se una sexp's è una cons-cell $(O A_1 A_2 \dots A_n)$ allora si procede nel seguente modo:
                \begin{itemize}
                  \item se $O$ è un operatore speciale la lista $(O A_1 \dots A_n)$
                        viene valutata in maniera speciale
                  \item se $O$ è un simbolo che denota una funzione nell'ambiente corrente
                        allora la funzione viene applicata alla lista $(VA_1 VA_2 \dots VA_n)$
                        indicanti i valori delle valutazioni degli argomenti della funzione.
                  \item Se $O$ è una espressione lambda la si applica agli argomenti
                  \item Altrimenti si segnala errore
                \end{itemize}
        \end{itemize}
  \item PRINT: viene stampato il risultato dell'espressione a video
\end{enumerate}
Le funzioni \textbf{apply} e \textbf{eval}, necessarie per valutare le espressioni,
possono essere scritte direttamente in Lisp, anche se sono già implementate in maniera standard,
in quanto in Lisp i dati e i programmi sono la stessa cosa.

Grazie a questo aspetto è possibile scrivere un interprete Lisp nel linguaggio stesso,
chiamato \textbf{interprete meta-circolare}, e cominciamo ora definendo la funzione valuta(eval è standard)
a partire dalle regole di valutazione definite.

La funzione valuta prende una sexp's e un ambiente env e ritorna una sexp's e procede nel seguente modo:
\begin{enumerate}
  \item 
\end{enumerate}



     (Parte della funzione EVAL E READ EVAL PRINT LOOP)
Lisp languages are often used with an interactive command line, which may be combined with an integrated development environment (IDE). The user types in expressions at the command line, or directs the IDE to transmit them to the Lisp system. Lisp reads the entered expressions, evaluates them, and prints the result. For this reason, the Lisp command line is called a read–eval–print loop (REPL).

The basic operation of the REPL is as follows. This is a simplistic description which omits many elements of a real Lisp, such as quoting and macros.

The read function accepts textual S-expressions as input, and parses them into an internal data structure. For instance, if you type the text (+ 1 2) at the prompt, read translates this into a linked list with three elements: the symbol +, the number 1, and the number 2. It so happens that this list is also a valid piece of Lisp code; that is, it can be evaluated. This is because the car of the list names a function—the addition operation.

Note that a foo will be read as a single symbol. 123 will be read as the number one hundred and twenty-three. "123" will be read as the string "123".

The eval function evaluates the data, returning zero or more other Lisp data as a result. Evaluation does not have to mean interpretation; some Lisp systems compile every expression to native machine code. It is simple, however, to describe evaluation as interpretation: To evaluate a list whose car names a function, eval first evaluates each of the arguments given in its cdr, then applies the function to the arguments. In this case, the function is addition, and applying it to the argument list (1 2) yields the answer 3. This is the result of the evaluation.

The symbol foo evaluates to the value of the symbol foo. Data like the string "123" evaluates to the same string. The list (quote (1 2 3)) evaluates to the list (1 2 3).

It is the job of the print function to represent output to the user. For a simple result such as 3 this is trivial. An expression which evaluated to a piece of list structure would require that print traverse the list and print it out as an S-expression.

To implement a Lisp REPL, it is necessary only to implement these three functions and an infinite-loop function. (Naturally, the implementation of eval will be complex, since it must also implement all special operators like if or lambda.) This done, a basic REPL is one line of code: (loop (print (eval (read)))).

The Lisp REPL typically also provides input editing, an input history, error handling and an interface to the debugger.

Lisp is usually evaluated eagerly. In Common Lisp, arguments are evaluated in applicative order ('leftmost innermost'), while in Scheme order of arguments is undefined, leaving room for optimization by a compiler.

\end{document}
