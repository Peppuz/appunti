%Capitolo sulla programmazione in Prolog
\chapter{Programming in Logic}
Dopo aver effettuato un ripasso della logica, incominciamo a considerare il Prolog e la programmazione logica:
le basi sono state poste da Robert Kowalski e Marten Van Emdem, mentre la progettazione e implementazione,
avvenne nel 1972 a Marsiglia grazie ad Alain Colmerauer e Philippe Roussel.

Il Prolog è un linguaggio di programmazione logica basato sulle clausole di Horn, la cui definizione sarà data in seguito,
e la procedura utilizzata dal Prolog per la computazione è il principio di risoluzione e di unificazione, anch'esso trattato in seguito.

Un programma logico è formato da un insieme di istruzioni, rappresentanti un sottoinsieme di frasi ben formate della logica del primo ordine
e l'ambiente Prolog determina se una data assunzione è verificata o meno nel programma e sotto quali eventuali vincoli.

I componenti basilari di un programma Prolog, rappresentanti tutti una clausola di Horn, sono:
\begin{description}
\item [Fatti]: indica una relazione esistente tra due oggetti, necessaria per stabilire la base di conoscenza del linguaggio.
               \begin{minted}{prolog}
                 worksFor(paolo, coop).
               \end{minted}
\item [Query]: chiede al sistema l'esistenza di una relazione tra gli oggetti e quindi inizia una deduzione per stabilire se la query
               è una conseguenza diretta del programma, dopo l'applicazione del principio di risoluzione per un numero finito di volte.
               \begin{minted}{prolog}
                 :- worksFor(paolo, trenord).
               \end{minted}

\item [Regole]: definisce una nuova relazione esistente tra gli oggetti, ossia permette di derivare una nuova conclusione dalla base di conoscenza.
                \begin{minted}{prolog}
                  parent(X, Y) :- father(X, Y).
                \end{minted}
                La testa della regola $A$, viene detta conseguenza mentre il corpo $B_1, B_2, \dots, B_n$ sono l'antecedente
                e il simbolo :- indica il simbolo logico di implicazione.\newline
                Una relazione può essere definita ricorsiva, per cui necessita di almeno due regole, una per il caso base e
                una per il caso passo, come il seguente esempio:
                \begin{minted}{prolog}
                    natural_number(0).
                    natural_number(s(X)) :- natural_number(X).%s(X) indica il successore di X
                \end{minted}
\end{description}
I fatti e le regole sono quantificate universalmente mentre una query si intende sempre quantificata esistenzialmente, per cui una query
risponde true se esiste un instanza $\alpha$ che la verifica altrimenti risponde false.

Le query e le regole le abbiamo definite nella forma generale, ossia possiamo definire regole e query su congiunzioni di termini,
infatti il simbolo \textbf{``,''} rappresenta l'operatore logico and, perciò in caso più termini hanno lo stesso simbolo di variabile
l'instanza $\alpha$ deve essere la stessa per stabilire se una query è una conseguenza diretta del programma.

Per vedere al meglio il concetto di implicazione vediamo la definizione del concetto di nonno nel linguaggio Prolog:
\begin{minted}{prolog}
  grandfather(X, Y) :- father(X, Z), parent(Z, Y).
\end{minted}
Questa relazione stabilisce che X è il nonno di Y se risulta che esiste un Z tale che X è padre di Z e Z è genitore di Y.

Ogni espressione prolog viene chiamata \emph{termine}, che può essere della seguente tipologia:
\begin{description}
\item [atomi] : elemento base del Prolog rappresentato da un numero, qualsiasi sequenza racchiusa tra ' ',
       una sequenza di caratteri alfanumerici, con la lettera minuscola iniziale, e nel SWI-Prolog anche una stringa indica un atomo.

\item [variabili] : sequenza di caratteri alfanumerici, iniziata con la lettera maiuscola oppure con \_ e vengono inizializzate
                    quando il sistema prova a dimostrare una query.\newline
                    Una variabile composta soltanto dal simbolo \_ viene detta \emph{anonima}.

\item [termini composti]: indicato da un funtore, simbolo usato per il nome di una funzione/predicato, e da una sequenza
  di termini all'interno di parentesi e separati da una virgola, usati per rappresentare gli argomenti del funtore.
\end{description}

Un programma caricato nel sistema prolog rappresenta una base di conoscenza, mostrabile nei seguenti modi:
\begin{itemize}
\item tutte le informazioni vengono rappresentate come argomenti in un'unica relazione e ciò può essere comodo solo per
  piccole relazioni dato che è difficile da mantenere e coprendere una relazione così definita.
  %inserire esempio
\item le informazioni vengono rappresentate con più relazione annidate tra di loro e ciò aumenta la leggibilità e
  la mantenibilità del programma prolog.
 %Inserire esempio
\item tutte le relazioni possono essere rappresentate tramite lo schema XML
\end{itemize}
Per riuscire a stabilire se un goals è una conseguenza diretta del programma il sistema prolog utilizza il principio di risoluzione,
utilizzato per effettuare la dimostrazione del programma , e il principio di unificazione, necessario come si evince dal nome per
unificare le variabili presenti in una formula del programma.

Nei prossimi due paragrafi considereremo questi due principi al fine di comprendere al meglio come avviene la computazione in un linguaggio logico.
\section{Principio di Risoluzione}
Il principio di risoluzione è una regola di inferenza generalizzata semplice e facilmente implementabile in un calcolatore
ed opera su formule ben formate nella forma normale congiuntiva, in cui i letterali si chiamano clausole.\newline
Questo principio viene utilizzato  per la dimostrazione di formule ben formate attraverso la refutazione per assurdo,
metodologia usata dall'interprete Prolog per computare una data query.

La regola di inferenza ha la seguente forma:
\begin{equation*}
  \frac{p\vee r,\, s\lor \neg r}{p\vee s}\,\,\,\,\,\,\,\,\,\,\frac{\neg r,\, r}{\perp}
\end{equation*}
dove:
\begin{itemize}
\item $p \lor  s$ è la \textit{clausola risolvente}
\item $\perp$ è la \textit{clausola vuota}, che corrisponde all'aver creato una contraddizione da cui posso dedurre qualsiasi cosa,
       compresa anche la clausola vuota.
\end{itemize}
Vediamo un'altra regola di inferenza, la\textbf{unit resolution}:
   \begin{equation*}
     \frac{\neg p,\,\, q_1\vee q_2\vee ... \vee q_k \vee p}{q_1\vee q_2\vee ... \vee q_k}
   \end{equation*}
o anche:
\begin{equation*}
  \frac{p,\,\, q_1\vee q_2\vee ... \vee q_k \vee \neg p}{q_1\vee q_2\vee ... \vee q_k}
\end{equation*}
è una regola di risoluzione molto generale, chiamata anche procedura di Davis-Putnam, e se una delle due clausole da risolvere
è un \textit{letterale} si parla di \emph{unit resolution}.\newline
Come esempio si può avere:
\begin{itemize}
\item non piove, piove e c'è il sole
\item si desume quindi che c'è il sole
\end{itemize}

Ogni FBF può essere in \emph{forma normale a clausola}:
\begin{itemize}
\item \emph{formula normale congiunta:} congiunzione di disgiunzioni o di negazione di predicati (sia positivi che negativi):
  \begin{equation*}
    \bigwedge_i(\bigvee_iL_{ij})
  \end{equation*}
\begin{esempio}
ecco degli esempi:
\begin{itemize}
\item $(p(x)\lor q(x,y)\lor \neg t(z))\land(p(w)\lor \neg s((u)\lor \neg r(v))$
\item $(\neg t(z))\lor (p(w)\lor \neg s(u))\land (p(x)\lor s(x)\lor q(y))$
\end{itemize}
\end{esempio}

\item \textit{forma normale disgiunta}: disgiunzione di congiunzioni o di negazione di predicati (sia positivi che negativi)
  \begin{equation*}
    \bigvee_i(\bigwedge_j L_{ij})
  \end{equation*}
\end{itemize}
Le clausole con un solo letterale positivo solo le \textit{clausole di Horn}, con lo presenza o meno di letterali negativi,
usate per rappresentare tutti i termini delle formule in Prolog.\newline
Ovviamente non tutte le formule ben formate possono essere rappresentate tramite le clausole di Horn per cui il Prolog è un sottoinsieme
della logica del Primo Ordine.\newline
Attraverso questa restrizione nel 1974 Kowalski produsse un interpretazione procedurale delle dimostrazione e ciò diventò la base
della semantica del Prolog.
%Semantica in Prolog
\section{Principio di Unificazione}
Il principio di unificazione è il cuore del modello di computazione dei programmi logici ed è alla base della deduzione automatica
e dell'uso dell'inferenza logica nell'intelligenza artificiale.

Per poter definirlo dobbiamo introdurre le seguenti definizioni:
\begin{defi}
Un termine $t$ è un instanza comune  di $t_1$ e $t_2$ se esistono le sostituzioni $\alpha_1$ e $\alpha_2$
che rendono $t$ uguale a $\alpha_1t_1$ e a $\alpha_2t_2$.\newline
Un termine $s$ è un termine generale del termine $t$ se $t$ è un'istanza di $s$ ma $s$ non è un istanza di $t$.\newline
Un termine $s$ è una variante alfabetica del termine $t$ se $t$ è un istanza di $s$ e $s$ è un istanza di $t$.
\end{defi}
L'unificazione tra due termini consiste nell'effettuare una sostituzione che rende i due termini identici
per cui c'è una relazione chiusa con l'instanza comune di due termini.

Il principio di unificazione consiste nel trovare il \emph{mgu}(Most general unifier),
l'unificazione la cui instanza comune è un termine generale, e in caso non lo trova riporta un fallimento.\newline
Presentiamo ora alcuni esempi per capire come funziona il Mgu:
\begin{minted}{prolog}
Mgu(42, 42) % ->{} non serve nessuna sostituzione
Mgu(42, X) % ->{X/42} ovvero X deve essere 42
Mgu(X,42) % ->{X/42} ovvero X deve essere 42
Mgu(foo(bar, 42), foo(bar, X)) % ->{X/42} ovvero X deve essere 42
Mgu(foo(Y, 42), foo(bar, X)) % ->{Y/bar, X/42} ovvero X deve essere 42
Mgu(foo(bar(42), baz), foo(X, Y))  /* ->{X/bar (42), Y/baz}
 ovvero X deve essere  bar(42) e Y baz*/
Mgu(foo(X), foo(bar(Y)))
Mgu(foo(bar(42), baz), foo(X, Y))  /* ->{X/bar (y), Y_:G001}
 ovvero non si ha soluzione */
\end{minted}
L'Mgu non è altro che il risultato finale della procedura di valutazione del Prolog ed il modo più semplice per vedere
se l'unificazione è corretta effettuiamo le seguenti interrogazioni al sistema Prolog:
\begin{minted}{prolog}
?- 42 = 42.
Yes

?- 42 = X.
X = 42 % per rendere vera l'affermazione serve x = 42
Yes

?- foo(bar, 42) = foo(bar, X).
X = 42
Yes

?- foo(Y, 42) = foo(bar, X).
Y = bar
X = 42
Yes

?- foo(bar(42), baz) = foo(X, Y).
X = bar(42)
Y = baz
Yes

?- foo(X) = foo(bar(Y)).
X = bar(Y)
Y = _G001
Yes

?- foo(42, bar(X), trillian) = foo(Y, bar(Y), X).
No
\end{minted}

Vediamo ora un programma che effettua la somma tra due numeri naturali:
\begin{minted}{prolog}
sum(0, X, X).
sum(s(X), Y, s(Z)) -: sum(X, Y, Z).
\end{minted}
con $s(n)$ interpretato come il successore ($0=0,\, s(0)=1, \,s(s(0))=2,\dots $).\newline
Quando viene specificato un goal esso viene confrontato con tutte le clausole di programma, che usa il procedimento di negazione
e di trasformazione in sintassi Prolog come viene mostrato in dettaglio con questo esempio:
\begin{itemize}
\item  interroghiamo il programma:
  \begin{equation*}
  \begin{split}
    \exists X\,\,\, sum(s(0),\, 0,\, X)\,\,\,\,\,\{X\,/\, s(0)\} \\
    \exists W\,\,\, sum(s(s(0)),\, s(0), \, W)\,\,\,\,\,\{W\,/\, s(s(s(0)))\}
  \end{split}
  \end{equation*}
dove $\{X\,/\, s(0)\}$ e $\{W\,/\, s(s(s(0)))\}$ sono le sostituzioni che rappresentano il risultato
\item usiamo il procedimento di negazione e trasformazione in sintassi:
\begin{minted}{prolog}
:- sum(s(0), 0, N).    %{N / s(0)}
:- sum (s(s(0)), s(0), W).     %{W / s(s(s(0)))}
\end{minted}
con $\{N\, /\, s(0)\}$ e $\{W \,/\, s(s(s(0)))\}$ che sono le sostituzioni.
\end{itemize}
Una computazione corrisponde al tentativo di dimostrare, tramite la regola di risoluzione, che una formula segue logicamente da un programma
e si ha inoltre che si deve determinare una sostituzione per le variabili del goal per cui la query segue  logicamente dal programma:
\begin{esempio}
Sia dato il programma P e la query:
\begin{minted}{prolog}
:- p(t1, t2, ..., tm).
\end{minted}
se \textbf{X1,..., Xn} sono le variabili in \textbf{t1,..., tm}, il significato della query è:
\begin{equation*}
  \exists X1,\,..., \,Xn\, . \,p(t1, t2, ..., tm)
\end{equation*}
e si cerca una sostituzione:
\begin{equation*}
  s=\{X1\,/\,s1,...,\, Xn\,/\,sn\}
\end{equation*}
con gli $s\,i$ termini tali per cui:
\begin{equation*}
  P\vdash s[p(t1, t2, ..., tm)]
\end{equation*}
\end{esempio}
Dato un insieme di clausole di Horn è possibile derivare la clausola vuota solo se c'è almeno una clausola senza testa, ovvero una query $G_0$
, in cui si deve dimostrare che da $P \cup G_0$ si può derivare la clausola e ciò avviene per assurdo col principio di risoluzione.\newline
Nel prossimo paragrafo vediamo come effuttua la risoluzione il sistema Prolog, che per efficienza usa una forma particolare di risoluzione.
\subsection{Risoluzione ad Input Lineare (SLD)}
Come già visto, il sistema Prolog per dimostrare la veridicità di un goal esegue una sequenza di passi di risoluzione,
il cui ordine di esecuzione determina sistemi di prova più o meno efficienti.\newline
In Prolog la risoluzione avviene sempre fra l’ultimo goal derivato in ciascun passo e una clausola di programma
e questa forma è detta \emph{Risoluzione-SLD}, dove le sentenze lineari sono le clausole di Horn.
\begin{defi}
Partiamo dal goal $G_i$:
\begin{equation*}
  G_i\equiv \,\,\,?-\, A_{i,\, 1}, ...,  A_{i,\, m}.
\end{equation*}
e dalla regola:
\begin{equation*}
  A_r\,\,\,:-\,\,\, B_{r,\,1},..., B_{r,\,k}.
\end{equation*}
Se esiste un unificatore $\sigma$ tale che $\sigma[A_r]=\sigma[A_{i,\,1}]$ allora si ottiene il nuovo goal:
\begin{equation*}
  G_{i+1}\equiv\,\,\,B^{'}_{r,\,1},..., B^{'}_{r,\,k},A^{'}_{i,\, 1}, ...,  A^{'}_{i,\, m}.
\end{equation*}
che è un passo di risoluzione eseguito dal sistema Prolog (con $\sigma[A_{i,\,m}]=A^{'}_{i,\,m}$ 4 $\sigma[B_{i,\,m}]=B^{'}_{i,\,m}$.\newline
La scelta di unificare il primo sottogoal di $G_i$ è arbitraria infatti si sarebbe potuto scegliere un arbitario sottogoal di $G_i$.

Partiamo dal goal $G_i$:
\begin{equation*}
  G_i\equiv \,\,\,?-\, A_{i,\, 1}, ...,  A_{i,\, m}.
\end{equation*}
e dalla regola (ovvero dal \textbf{fatto}): $A_r$.
se esiste un unificatore $\sigma$ tale che $\sigma[A_r]=\sigma[A_{i,\,1}]$ allora si ottiene il nuovo goal:
\begin{equation*}
  G_{i+1}\equiv\,\,\,A^{'}_{i,\, 2}, ...,  A^{'}_{i,\, m}.
\end{equation*}
che ha dimensioni minori di $G_i$ avendo $m-1$ sottogoal
\end{defi}
Nella risoluzione SLD si possono avere i seguenti risultati:
\begin{itemize}
\item \textbf{successo:} si genera la clausola vuota, ovvero se per $n$ finito $G_n$ è uguale alla clausola vuota $G_:n\equiv\,\,\,:-$
\item \textbf{insuccesso finito}: se per $n$ finito $G_n$  non è uguale alla clausola vuota $G_:n\equiv\,\,\,:-$
              e non è più possibile derivare un nuovo \textit{risolvente} da $G_n$ ed una clausola d programma.
\item \textbf{insuccesso infinito: }se è sempre possibile derivare nuovi risolventi tutti diversi dalla clausola vuota.
\end{itemize}
La \textbf{sostituzione di risposta} è la sequenza di unificatori usati ed applicata alle variabili nei termini del goal iniziale
determina la risposta finale restituita dal sistema Prolog.\newline
Durante il processo di generazione di goal intermedi si costruiscono delle varianti dei letterali e delle clausole coinvolti
mediante larinominazione di variabili infatti una variante per una clausola $C$ é la clausola $C^{'}$ ottenuta da $C$ rinominando le sue variabili
\begin{esempio}
esempio:
\begin{minted}{prolog}
p(X) :- q(X, g(Z)).
% è uguale alla clausola con variabili rinominate:
p(X1) :- q(X1, g(FooFrobboz)).
\end{minted}
\end{esempio}
Possono esserci più clausole di programma utilizzabili per applicare la risoluzione con il goal corrente ed esistono diverse strategie di ricerca:
\begin{itemize}
\item \textbf{in profondità (Depth First)}: si sceglie una clausola e si mantiene fissa questa scelta, finché non si arriva alla clausola vuota
  o alla impossibilità di fare nuove risoluzioni: in questo ultimo caso si riconsiderano le scelte fatte precedentemente e si riparte a dimostrare
  in profondità fino a quando è possibile effettuare delle scelte.
\item \textbf{in ampiezza (Breadth First)}: si considerano in parallelo tutte le possibili alternative
\end{itemize}
Ogni sistema di programmazione logica sceglie la propria strategia e il Prolog ha deciso di adottare una strategia di risoluzione
in profondità con backtracking, ossia la possibilità di ritornare indietro e provare tutte le possibilità.

Introduciamo ora l'importante argomento degli alberi di derivazione, per analizzare come un sistema Prolog effettua la computazione
e quali passi esegue per riuscire a stabilire se una data query deriva dal programma o meno.
\begin{defi}
Dato un programma logico $P$, un goal $G_i$ e una regola di calcolo $R$ si ha che un \textit{albero SLD} per $P\cup G_i$ via $R$
è definito sulla base del processo di prova visto precedentemente:
\begin{itemize}
\item ciascun \textbf{nodo} dell'albero è un goal (possibilmente vuoto)
\item la \textbf{radice }dell'albero SLD è il goal $G_0$
\item dato il nodo: $:-\,\,\, A_1,...,A_{m-1},A_m,A_{m+1},...,A_k$
  se $A_m$ è il sottogoal selezionato dalla regola di calcolo $R$, allora questo nodo (genitore) ha un nodo figlio
  per ciascuna clausola del tipo:
  \begin{equation*}
    \begin{split}
      C_i\equiv A_i\,\,\, :-\,\,\, B_{i,\,1},...,B_{i,\,q}\\
      C_k \equiv A_k \\
    \end{split}
  \end{equation*}
di $P$ tale che $A_i$ e $A_m$ ($A_K$ e $A_m$) sono unificabili attraverso la sostituzione più generale $\sigma$.\newline
Il nodo figlio è etichettato con la clausola goal
\begin{equation*}
\begin{split}
      :-\,\,\,\sigma[A_1,...,A_{m-1},B_{i,\,i},...,B_{i,\,q},A_{m+1},...,A_k]\\
      :-\,\,\,\sigma[A_1,...,A_{m-1},A_m,A_{m+1},...,A_k]\\
\end{split}
\end{equation*}
e il ramo dal nodo padre al figlio è etichettato dalla sostituzione $\sigma$ e dalla clausola selezionata $C_i$ o $C_k$
ed infine si ha che il nodo $:-$ non ha figli.
\end{itemize}
\end{defi}
La regola $R$ è variabile e le più comuni utilizzate sono:
\begin{itemize}
\item \textbf{Left-most}: si sceglie sempre di risolvereil sottogoal più a sinistra
\item \textbf{Right-most}: si sceglie sempre la risoluzione del sottogoal più a destra
\item si può avere la scelta di un sottogoal a caso
\item se si ha un modo per decider il miglior sottogoal
\end{itemize}
Ogni sistema logico decide la propria modalità di applicazione della regola e il sistema Prolog ha deciso di
usare sempre la regola left-most.\newline
L'albero SLD, generato implicitamente dal sistema Prolog, ordina i figli di un nodo secondo l'ordine dall'alto verso il basso
delle regole e dei fatti del programma P, come si nota nell'esempio mostrato di seguito.
\begin{esempio}
Ecco un esempio:
\begin{center}
\includegraphics[scale=0.7]{img/alb.png}
\end{center}
\end{esempio}
Ad ogni ramo di un albero SLD corrisponde una derivazione SLD e ogni ramo che termina con il nodo vuoto $:-$.\newline
La regola di calcolo influisce sulla struttura dell'albero per quanto riguarda l'ampiezza e la profondità ma non influisce
sulla correttezza e completezza, infatti tra un albero left-most e un albero right-most cambia solo l'ordine e il tempo necessario
per stabilire se un ramo è un successo oppure no.
\begin{esempio}
  Ecco un altro esempio, con fallimento infinito, dove la clausola vuota può essere generata ma il Prolog non è in grado di trovare
  questa soluzione dato che la sua strategia di percorrimento dell’albero (implicito) di soluzioni è depth-first con backtracking :
\begin{center}
\includegraphics[scale=0.7]{img/alb2.png}
\end{center}
\end{esempio}
\subsection{Cut e Backtracking}
Introduciamo ora il predicato \emph{Cut}, attraverso cui possiamo controllare il backtracking, in quanto si tagliano certe possibilità
di ritornare indietro nelle scelte durante la computazione.\newline
Il predicato cut si indica con $!$ e il Prolog effettua un'interpretazione procedurale, sempre per il fatto che viene eseguito su un calcolatore.

Come abbiamo affermato precedentemente, le clausole nel data base di un programma Prolog vengono considerate “da sinistra, verso destra”
e “dall'alto al basso” per cui se un (sotto)goal fallisce, allora il dimostratore Prolog, sceglie un'alternativa,
scandendo “dall'alto” verso “il basso” la lista delle clausole.\newline
Questa procedurà può venire controllata dal \textit{cut} infatti per esempio:
\begin{minted}{prolog}
a :- b1, b2, ..., bk, !, ..., bn.
\end{minted}
Questo è l'effetto del cut:
\begin{itemize}
\item se il goal corrente \textit{G} unifica con \textit{a} e $b_1,...,b_k$ hanno successo,
      allora il dimostratore si impegna inderogabilmente alla scelta di C per dimostrare G.
\item ogni clausola alternativa (successiva, in basso) per \textit{a} che unifica con \textit{G} viene ignorata
\item se un qualche $b_j$ con $j > k$ fallisse, il backtracking si fermerebbe al cut e le altre scelte sono rimosse dall'albero di derivazione
\item quando il backtracking raggiunge il cut, allora il cut fallisce e la ricerca procede dall’ultimo punto di scelta
      prima che \textit{G} scegliesse \textit{C}
\end{itemize}
Il Prolog per la gestione della computazione utilizza due stack:
\begin{itemize}
\item stack delle scelte: contiene l'insieme delle scelte possibili ed ad ogni fase della valutazione contiene i puntatori alle
      scelte aperte nelle fasi precedenti della dimostrazione
\item stack di esecuzione: contiene i record di attivazione delle varie procedure, ovvero le sostituzioni per l'unificazione delle varie regole.
\end{itemize}
Vediamo un albero di derivazione in caso di cut:
\begin{center}
	\includegraphics[scale=0.8]{img/cut.png}
\end{center}
Si hanno due tipi di cut:
\begin{itemize}
\item \textbf{green cut:} utili per esprimere il “determinismo”, come vedremo ora, e quindi per rendere più efficiente il programma
  in quanto non vengono analizzate clausole certamente false.
\item \textbf{red cut:} usati per soli scopi di efficienza ed hanno come caratteristica principale quella di omettere alcune condizioni
                        esplicite in un programma, ma soprattutto  quella di modificare la semantica del programma.
\end{itemize}
Per capire l'importanza e l'utilizzo del cut, consideriamo ora il seguente codice:
\begin{minted}{prolog}
/* merge di due liste ordinate*/

merge([X | Xs], [Y | Ys], [X | Zs]) :-
	X < Y,
	merge(Xs, [Y | Ys], Zs).
merge([X | Xs], [Y | Ys], [X, Y | Zs]) :-
	X = Y,
	merge(Xs, Ys, Zs).
merge([X | Xs], [Y | Ys], [Y | Zs]) :-
	X > Y,
	merge([X | Xs], Ys, Zs).
merge([], Ys, Ys).
merge(Xs, [], Xs).

/+ minimo tra due numeri */
minimum(X, Y, X) :- X =< Y.
minimum(X, Y, Y) :- Y < X.
\end{minted}
Vediamo cosa succede come computazione nell'interprete Prolog:
\begin{center}
\includegraphics[scale=0.8]{img/cut2.png}
\end{center}
consideriamo la seguente query:
\begin{minted}{Prolog}
?- merge([], [], Xs).
Xs = [];
Xs = [];
False.
\end{minted}
Questa implementazione del merge ha purtroppo una soluzione di troppo e questo è un esempio di determinismo, ossia
quando una sola delle clausole serve (o si vorrebbe servisse) per provare un dato goal.\newline
Si usano quindi i seguenti green cuts:
\begin{minted}{prolog}
merge([X | Xs], [Y | Ys], [X | Zs]) :-
	X < Y, !,
	merge(Xs, [Y | Ys], Zs).
merge([X | Xs], [Y | Ys], [X, Y | Zs]) :-
	X = Y, !,
	merge(Xs, Ys, Zs).
merge([X | Xs], [Y | Ys], [Y | Zs]) :-
	X > Y, !,
	merge([X | Xs], Ys, Zs).
merge([], Ys, Ys) :- !.
merge(Xs, [], Xs) :- !.
\end{minted}
Interrogando il sistema Prolog come il seguente esempio otteniamo:
\begin{minted}{Prolog}
?- merge([], [], Xs).
Xs = [];
False.
\end{minted}
Guardando ai passi necessari, effettuati dall'interprete Prolog, per rispondere ad un query abbiamo:
\begin{center}
\includegraphics[scale=0.8]{img/cut3.png}
\end{center}
Il predicato per calcolare il minimo diventa:
\begin{minted}{prolog}
minimum(X, Y, X) :- X =< Y, !.
minimum(X, Y, Y) :- Y < X, !.%è ridontante ma viene inserito per simmetria
\end{minted}
Una volta che il programma ha fallito la prima clausola (ovvero il test X =< Y) al sistema Prolog non rimane che controllare la
clausola seguente.\newline
Riscrivo in maniera non simmetrica:
\begin{minted}{prolog}
minimum(X, Y, X) :- X =< Y, !.
minimum(X, Y, Y).
\end{minted}
Qui si ha un red cut dato che taglia solo delle soluzioni, portando anche a risultati errati, infatti $minimum(2, 5, 5)$ risulta verificato
dato che il secondo termine è un fatto sempre verificato.

\section{Strutture Dati ed ambiente Prolog}
Si definisce una lista in Prolog racchiudendo gli elementi (termini e/o variabili logiche) della lista tra parentesi quadre [ e ]
e separandoli da virgole.\newline
Gli elementi di una lista in Prolog possono essere termini qualsiasi o liste e la lista vuota si indica con [].\newline
Una lista non vuota si può dividere in \textit{testa} e \textit{coda}:
\begin{itemize}
\item la testa è il primo elemento della lista
\item la coda rappresenta tutto il resto ed è sempre una lista
\end{itemize}
Presentiamo ora degli esempi di liste in Prolog:
\begin{minted}{prolog}
[a, b, c] % a è la testa e [b, c] la coda
[a, b] % a è la testa e [b] la coda
[a] % a è la testa e [] la coda
[[a]] % [a] è la testa e [] la coda
[[a, b], c] % [a, b] è la testa e [c] la coda
[[a, b], [c], d] % [a, b] è la testa e [[c], d] la coda
\end{minted}
Prolog possiede uno speciale operatore usato per distinguere tra l'inizio e la coda di una lista: l'operatore \textbf{|}:
\begin{minted}{prolog}
?- [X | Ys] = [mia, vincent, jules, yolanda].
X = mia
Ys = [vincent, jules, yolanda]
Yes

?- [X, Y | Zs] = [the, answer, is, 42].
X = the
Y = answer
Zs = [is, 42]
Yes

?- [X, 42 | _] = [41, 42, 43, foo(bar)].
X = 41
Yes
\end{minted}
La lista vuota in prolog è gestita come una lista speciale infatti risulta:
\begin{minted}{prolog}
?- [X | Ys] = [].
No
\end{minted}
Nonostante le liste sono definite di default in Prolog, con anche molte operazioni implementate come append, length ed ecc...,
definiamo una libreria personale per gestire le liste infatti questo è il codice per implementare una lista in Prolog:
\inputminted{Prolog}{esempi/liste.pl}
In Prolog la base di conoscenza è nascosta al controllo diretto degli utenti ed è accessibile solo tramite opportuni comandi per cui
bisogna poter caricare un insieme di fatti e regole nell'ambiente Prolog, nel nostro caso SW-Prolog.\newline
Per farlo si ha il comando \textbf{consult}, che appare come un predicato da valutare (un goal) e prende almeno un termine che denota un file
come argomento, contenente la nostra base di conoscenza.
\begin{minted}{prolog}
?- consult(’guida-astrostoppista.pl’).
Yes

?- consult(’Projects/Lang/Prolog/Code/esempi-liste.pl’).
Yes
\end{minted}
Il predicato \textbf{reconsult} viene usato quando si vuole ricaricare un file nell'ambiente Prolog.\newline
L’effetto è di prendere i predicati presenti nel file, rimuoverli completamente dal data base interno
e di reinstallarli utilizzando le nuove definizioni:
\begin{minted}{prolog}
?- reconsult(’guida-astrostoppista.pl’).
Yes
% A questo punto la base di dati Prolog contiene il
% nuovo contenuto del file.

?- reconsult(user). % Notare il sotto-prompt.
|- foo(42).
|- friends(zaphod, trillian).
|- ^D
Yes

% A questo punto la base di dati Prolog contiene i due
% fatti inseriti manualmente.
?- friends(zaphod, W).
W = trillian
Yes
\end{minted}

\section{Caratteristiche particolari del sistema Prolog}
Dopo aver visto i background teorici e alcuni esempi basilari di programmi logici, introduciamo alcune caratteristiche più avanzate
per poter semplificare e rendere più efficiente un programma prolog, ed incominciamo dall'aritmetica.
\subsection{Aritmetica in Prolog}
Il Prolog fornisce dei predicati standard per gestire ed effettuare le operazioni aritmetiche, i quali a differenza dei soliti predicati
che derivano dalla logica, questi effettuano ed eseguono  direttamente usando l’hardware, perdendo la possibilità di effettuare
l’instanzazione tramite l’unificazione ma dovendola fare direttamente alla chiamata dei predicati aritmetici.\newline
Il Prolog prevede ed usa gli operatori matematici, con la loro relativa precedenza, $+ - * /$.\newline
I predicati standard comunemente usato per la gestione dell’aritmetica sono i seguenti:
\begin{itemize}
    \item $>$(Expr1, Expr2): stabilisce se Expr1 è maggiore dell’Expr2
    \item $<$(Expr1,Expr2): stabilisce se Expr1 è minore di Expr2
    \item $<=$(Expr1,Expr2): vero se Expr1 è minore o uguale a Expr2
    \item $>=$(Expr1,Expr2): verificato se Expr1 è maggiore di Expr2
    \item $\\=$(Expr1,Expr2): verificato se Expr1 è diverso ad Expr2
    \item $=$(Expr1,Expr2): verificato se l’Expr1 viene valutata come l’Expr2
    \item $is$(Number,Expr2): verificato se Number è la valutazione di Expr2
\end{itemize}
Esempi:

\subsection{Predicati Meta-Logici}
Vediamo il predicato:
\begin{minted}{prolog}
celsius_fahrenheit(C, F) :- C is 5/9 * (F - 32).
\end{minted}
Questo predicato non è invertibile infatti si deve decidere qual è l'input e qual è l'output ma per risolvere il problema usiamo
i predicati meta-logici, introdotti in questo paragrafo.\newline
La ragione dell'impossibilità di invertire deriva dall'uso che abbiamo fatto di vari predicati aritmetici nel corpo dei predicati
(>, <, =<, is, etc), infatti per poter usare i predicati aritmetici che usano direttamente l'hardware
abbiamo sacrificato la semantica dei nostri programmi.

I predicati meta-logici principali trattano le variabili come oggetti del linguaggio e ci permettono di riscrivere molti programmi
che usano i predicati aritmetici di sistema come predicati dalla semantica “corretta” ed dal comportamento invertibile.\newline
I comuni predicati predicati importanti:
\begin{itemize}
\item \textit{var(X):}  vero se \textit{X} è una variabile logica
\item \textit{nonvar(X):}  vero se \textit{X} non è una variabile logica
\item \textit{integer(X):} risulta verificato se \textit{X} è un intero
\item \textit{number(X):} risulta verificato se X è un numero intero o in virgola mobile
\item \textit{float(X):}: risulta verificato se X è un numero in virgola mobile
\end{itemize}
ovvero:
\begin{minted}{Prolog}
?- var(foo).
False
?- var(X).
True
?- nonvar(42).
True
?- integer(45).
True
?- integer(abc).
False
?- number(12.456).
True
?- number(a).
False
\end{minted}
il nostro programma dei gradi diventa:
\begin{minted}{prolog}
celsius_fahrenheit(C, F) :-
	var(C), nonvar(F), C is 5/9 * (F - 32).
celsius_fahrenheit(C, F) :-
	var(F), nonvar(C), F is (9/5 * C) + 32
\end{minted}
con var decido che clausola usare e l'uso di questi predicati ci permette di scrivere programmi efficienti e semanticamente corretti.

Posso chiedere a prolog se ho a che fare con termini atomici o scomposti, con i seguenti predicati:
\begin{itemize}
\item \textit{atomic(X):}vero se \textit{X} è un numero od una costante
\item \textit{compound(X):} vero se non \textit{atomic(X)}
\item \textit{atom(X)}: verificato se e solo se X è una costante ma non accettale stringhe
\end{itemize}
Esempi:
\begin{minted}{prolog}
?- atomic(43).
True
?- atomic(foo(bar)).
False
?- compound(42).
False
?- compound(foo(X)).
True
\end{minted}
Ho per manipolare un termine, denotato con \emph{Term}, i seguenti principali predicati:
\begin{itemize}
\item \textbf{functor(Term, F, Arity)},
vero se \emph{Term} è un termine, con \emph{Arity}argomenti, il cui funtore (simbolo di funzione o di predicato) è \emph{F}.
\item \textbf{arg(N, Term, Arg)},
vero se l’N-esimo argomento di \emph{Term }è \emph{Arg}.
\item \textbf{Term =.. L}
  questo predicato, =..,viene chiamato (per motivi storici) \textbf{univ}; risulta verificato quando L è una lista
  il cui primo elemento è il funtore di \textit{Term} ed i rimanenti elementi sono i suoi argomenti.
\end{itemize}
ovvero:
\begin{minted}{prolog}
?- functor(foo(24), foo, 1).
YES
?- functor(node(x, _, [], []), F, 4).
F = node
Yes
?- functor(Term, bar, 2).
Term = bar(_0,_1)
Yes
?- arg(3, node(x, _, [], []), X).
X = []
Yes
?- arg(1, father(X, lot), haran).
X = haran
Yes
?- father(haran, lot) =.. Ts.
Ts = [father, haran, lot]
Yes
?- father(X, lot) =.. [father, haran, lot].
X = haran
Yes
\end{minted}
\subsection{Programmazione di ordine superiore}
Quando si formula una domanda per il sistema Prolog, ci si aspetta una risposta che è un'istanza (individuale) derivabile dalla knowledge base
e col backtracking ne otteniamo una alla volta, ma se io volessi tutte le risposte si entrerebbe nel campo della logica del secondo ordine.\newline
Per risolvere questo problema il sistema Prolog fornisce i seguenti predicati:
\begin{itemize}
\item \textbf{findall(Template, Goal, Set):}
\begin{itemize}
\item Vero se Set contiene tutte le istanze di Template che soddisfano Goal
\item \textit{Le istanze di Template vengono ottenute mediante backtracking}
\end{itemize}
\item \textbf{bagof(Template, Goal, Bag):}
\begin{itemize}
\item Vero se Bag contiene tutte le alternative di Template che soddisfano Goal
\item Le alternative vengono costruite facendo backtracking solo se vi sono delle variabili libere in Goal che non appaiono in Template
\item È possibile dichiarare quali variabili non vanno considerate libere al fine del backtracking grazie alla sintassi $Var^G$ come Goal;
  In questo caso Var viene pensata come una variabile esistenziale
\end{itemize}
\item \textit{setof(Template, Goal, Set)}, che si comporta come bagof, ma Set non contiene soluzioni duplicate
\end{itemize}
Per comprendere al meglio presentiamo i seguenti esempi:
\begin{minted}{prolog}
/* findall */

?- findall(C, father(X, C), Kids).
C = _0
X = _1
Kids = [abraham, nachor, haran, isaac, lot, milcah, yiscah]
True.

/* bagof */

?- bagof(C, father(X, C), Kids).
C = _0
X = terach
KIDS = [abraham, haran, nachor];
C = _0
X = haran
KIDS = [lot, yiscah, milcah];
C = _0
X = abraham
KIDS = [isaac];
False.

/* bagof con variabile esistenziale */

?- bagof(C, X^father(X, C), Kids).
C = _0
X = _1
Kids = [abraham, haran, lot, yiscah, nachor, isaac, milcah];
False.
\end{minted}
Buona parte dei predicati di ordine superiori, funzionano grazie al meccanismo delle meta-variabili, ovvero variabili interpretabili come goals.

Per esempio si ha il predicato \textit{call}:
\begin{minted}{prolog}
call(G) :- G.
\end{minted}
Possiamo quindi definire il predicato \textit{apply} che valuta una query composta da un funtore e da una lista di argomenti:
\begin{minted}{prolog}
apply(P, Argomenti) :-
  P =.. PL, append(PL, Argomenti, GL), Goal =.. GL, call(Goal).
\end{minted}
\begin{shaded}
\begin{lstlisting}[language=prolog]
?- apply(father, [X, C]).
X = terach
C = abraham;
X = terach
C = nachor;
False

?- apply(father(terach), [C]).
C = abraham;
C = nachor;
False
\end{lstlisting}
\end{shaded}
\subsection{Manipolazine della base di Dati}
Un programma Prolog è costituito da una base di conoscenza(knowledge base) che contiene \textbf{fatti} e \textbf{regole},
su cui il programma interroga il sistema per sapere se una data query risulta verificata.\newline
Il Prolog però mette a disposizione anche altri predicati che servono a manipolare direttamente la base di dati ma ovviamente,
questi predicati vanno usati con molta attenzione, dato che modificano dinamicamente lo stato del programma:
\begin{itemize}
\item listing: per mostrare tutti gli elementi della base di conoscenza
\item assert, asserta, assertz: per effettuare un'asserzione ossia inserire elementi nella nostra base di conoscenza
\item retract: per eliminare gli elementi in una base di conoscenza
\item abolish: per abolire degli elementi
\end{itemize}
se si ha una knowledge base vuota si avrà:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- listing.
True
\end{lstlisting}
\end{shaded}
ovvero solo True e il \textit{listing} è vuoto.\newline
Aggiungo ora qualcosa alla base dati con:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- assert(happy(maya)).
true
\end{lstlisting}
\end{shaded}
che risponderà sempre \textit{true}, ora si avrà:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- listing.
happy(maya).
true
\end{lstlisting}
\end{shaded}
e la base dati non sarà più vuota.\newline
Aggiungo altro alla base dati:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- assert(happy(vincent)).
true

?- assert(happy(marcellus)).
true

?- assert(happy(butch)).
true

?- assert(happy(vincent)).
true
\end{lstlisting}
\end{shaded}
il \textit{listing} ora darà:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- listing.
happy(mia).
happy(vincent).
happy(marcellus).
happy(butch).
happy(vincent).
true
\end{lstlisting}
\end{shaded}
Si possono anche asserire regole usando assert e mettendo la regola tra parentesi:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- assert( (naive(X) :- happy(X)) ).
true

?- listing.
happy(mia).
happy(vincent).
happy(marcellus).
happy(butch).
happy(vincent).
naive(A) :-
happy(A).
true
\end{lstlisting}
\end{shaded}
possiamo anche rimuovere fatti e regole con retract, riprendendo dagli esempi sopra:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- retract(happy(marcellus)).
true

?- listing.
happy(mia).
happy(vincent).
happy(butch).
happy(vincent).
naive(A) :-
happy(A).
true
\end{lstlisting}
\end{shaded}
inoltre si ha che retract rimuove solo la prima occorrenza:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- listing.
happy(mia).
happy(vincent).
happy(butch).
happy(vincent).
naive(A) :-
happy(A).
true

?- retract(happy(vincent)).
true

?- listing.
happy(mia).
happy(butch).
happy(vincent).
naive(A) :-
happy(A).
true
\end{lstlisting}
\end{shaded}
Per rimuovere tutte le nostre asserzioni possiamo usare una variabile:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- retract(happy(X)).
X = mia;
X = butch;
X = vincent;
false

?- listing.
naive(A) :-
happy(A)
true
\end{lstlisting}
\end{shaded}
Per avere più controllo su dove vengono aggiunti fatti e regole possiamo usare le due varianti di assert:
\begin{enumerate}
\item assertz: inserisce l’asserzione alla fine della knowledge base
\item asserta: inserisce l’asserzione all'inizio della knowledge base
\end{enumerate}
ovvero, partendo da una base dari vuota:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- assert(p(b)), assertz(p(c)), asserta(p(a)).
true

?- listing.
p(a).
p(b).
p(c).
true
\end{lstlisting}
\end{shaded}
La manipolazione dati può essere usata per memorizzare i risultati intermedi di varie computazioni, in modo da non dover rifare
delle queries dispendiose in futuro: semplicemente si ricerca direttamente il fatto appena asserito e
questa tecnica si chiama \textbf{memorization} o \textbf{caching}.
\begin{esempio}
Creiamo una tavola di addizioni manipolando la knowledge base:
\begin{minted}{prolog}
addition_table(A) :-
  member(B, A),
  member(C, A),
  D is B + C,
  assert(sum(B, C, D)),
  fail.
\end{minted}
dove \textit{member(X, Y)} controlla che il predicato X appartenga alla lista Y.\\
\begin{shaded}
\begin{lstlisting}[language=bash]
?- addition_table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]).
false
\end{lstlisting}
\end{shaded}
La risposta è false; ma non è la risposta che ci interessa, bensì l’effetto (collaterale) che l’interrogazione ha sulla knowledge base:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- listing(sum).
sum(0, 0, 0).
sum(0, 1, 1).
sum(0, 2, 2).
sum(0, 3, 3).
...
sum(9, 9, 18).
true
\end{lstlisting}
\end{shaded}
potremmo ora rimuovere tutti questi fatti non con il solito
\begin{shaded}
\begin{lstlisting}[language=bash]
?- retract(sum(X, Y, Z)).
\end{lstlisting}
\end{shaded}
che dovremmo ripetere ogni volta per ogni fatto ma con:
\begin{shaded}
\begin{lstlisting}[language=bash]
?- retract(sum(_, _, _)), fail.
false
\end{lstlisting}
\end{shaded}
Ancora una volta, lo scopo del \emph{fail} è di forzare il backtracking infatti il Prolog rimuove il primo fatto con funtore sum dalla base di dati
e poi fallisce.\newline
Quindi fa backtrack e rimuove il fatto successivo e così via per cui alla fine, dopo aver rimosso tutti i fatti con funtore sum,
la query fallirà completamente ed il Prolog risponderà (correttamente) con un false.\newline
Ma anche in questo caso a noi interessa unicamente l’effetto collaterale sulla knowledge base.
\end{esempio}
\subsection{Input e Output in Prolog}
I predicati primitivi principali per la gestione dell'I/O in Prolog sono essenzialmente due, \textbf{read} e \textbf{write},
a cui si aggiungono i vari predicati per la gestione dei files e degli streams: \textbf{open, close, seek}, etc...
Il predicato write è l'equivalente del metodo \emph{toString} in Java su un oggetto di classe "termine" mentre \emph{read} invoca il parser prolog:
\begin{shaded}
\begin{minted}{prolog}
?- write(42).
42
true

?- foo(bar) = X, write(X).
foo(bar)
X = foo(bar)
?- read(What).
|: foo(42, Bar).
What = foo(42, _G270).

?- read(What), write('I just read: '), write(What).
|: read(What).
I just read: read(_G301)
What = read(_G301).

?- open(`some/file/here.txt', write, Out),
write(Out, foo(bar)), put(Out, 0’.), nl(Out),
close(Out).
true % But file ”some/file/here.txt” now contains the term ’foo
(bar).’

?- open(’some/file/here.txt’, read, In),
read(In, What)
close(In).
What = foo(bar)
\end{minted}
\end{shaded}
\textbf{open} e \textbf{close} servono per leggere e scrivere files; la versione più semplice di open ha con tre argomenti:
un atomo che rappresenta il nome del file, una “modalità” con cui si apre il file ed un terzo argomento a cui si associa l’identificatore del file.

Esiste anche il predicato \textbf{put} che emette un carattere sullo stream ed il predicato nl che mette un ‘newline’ sullo stream
ed il Prolog usa la notazione \textit{0'c} per rappresentare i caratteri come termini.
\section{Interpreti in Prolog}
Uno degli utilizzi del Prolog consiste nella costruzione di interpreti per la manipolazione di linguaggi specializzati(Domain Specific Languages),
i più famosi sono i seguenti:
\begin{itemize}
\item intepreti per Automi a Stati Finiti, Automi a Pila e  Macchine di Turing(collegamento con l'informatica Teorica)
\item sistemi per la deduzione automatica, utilizzati per il Machine Learning e AI
\item sistemi per la manipolazione del Linguaggio Naturale (Natural Language Processing)
\end{itemize}
In questo corso vediamo come definire un minimale, molto minimale, interprete per gli automi, incominciato per prima con quello a stati finiti:
\subsection{Interprete degli automi a stati finiti}
Dato il seguente automa:
\begin{center}
\includegraphics[scale=0.8]{img/aut.png}
\end{center}
in cui i nodi rappresentano degli stati e si ha uno stato inziale ($q_0$) e uno finale, denotato con un doppio cerchio, ($q_1$).\newline
Gli archi sono le transizioni tra due stati e nel nostro caso generano caratteri e nell'esempio ho soltanto stringhe che iniziano con $a$.\newline
In $q_1$ posso fermarmi e generare solo la stringa $a$ o produrre altri caratteri in numero variabile e le stringhe qui prodotte
saranno del tipo $ac^n(ba)^n$, con $n\geq 0$.\newline
Per decidere se una certa sequenza di simboli è riconosciuta dall’automa possiamo costruire il seguente predicato:
\begin{minted}{prolog}
/* definisco l'interprete */
accept([I | Is], S) :-
  delta(S, I, N),
  accept(Is, N).
accept([], Q) :- final(Q). /* è l'uscita, se ho una lista vuota
                               ho generato tutto */

/* richiesta di riconoscere un automa con stato iniziale S
    poi si usa l'accept con input che rappresenta la stringa
     considerando lo stato inziale S */
recognize(Input) :- initial(S), accept(Input, S).

initial(q0). % stato iniziale
final(q1). % stato finale

/* definisco le transizioni, con delta a tre argomenti */
delta(q0, a, q1).
delta(q1, b, q0).
delta(q1, c, q1).
\end{minted}
\begin{shaded}
\begin{lstlisting}[language=bash]
?- recognize([a, b, a, c, c, b, a]).
Yes

?- recognize([a, b, a, c, b]).
No
\end{lstlisting}
\end{shaded}
Per riuscire a comprendere come funziona l'interprete vediamo il suo funzionamento considerando la lista $[a,\,b,\,a,\,c,\,c,\,b,\,a]$,
in cui si hanno le seguenti sostituzioni: $I\backslash a$ e $S\backslash q0$.\newline
Avrò quindi:
\begin{minted}{prolog}
delta(q0, a, N).
accept([b, ...], N).
\end{minted}
Ora si effettuano le seguenti sostituzoni: $N\backslash q1$:
\begin{minted}{prolog}
accept([b, ...], q1). % è il nuovo goal
\end{minted}
unifico ancora con le sostituzioni $I2\backslash b$ e $Is\backslash [a,c,c,b,a]$:
\begin{minted}{prolog}
delta(q1, b, N2).
accept([a, c, c, b, a], N2).
\end{minted}
ad un certo punto arriveremo alla fine:
\begin{minted}{prolog}
accept([], q1).
\end{minted}
che unifica con la seconda clausola, sostituendo $q1\backslash Q$, arrivando a:
\begin{minted}{prolog}
final(q1).
\end{minted}
Dopo aver considerato come si definisce un interprete per automi, possiamo considerare degli interpreti più sofisticati
se accettiamo di rappresentare i programmi, usando una sintassi leggermente diversa:
\begin{minted}{prolog}
rule(append([], X, X)).
rule(append([X | Xs], Ys, [X | Zs]), [append(Xs, Ys, Zs)]).

solve(Goal) :- solve(Goal, []). /* lista goal e lista di appoggio
                                    dove mettere i goal restanti */

solve([], []). % clausola di uscita

solve([], [G | Goals]) :-
  solve(G, Goals).
solve([A | B], Goals) :-
  append(B, Goals, BGoals),
  solve(A, BGoals).
solve(A, Goals) :-
  rule(A),
  solve(Goals, []).
solve(A, Goals) :-
  rule(A, B),
  solve(B, Goals).
\end{minted}
Il programma \textit{solve} è un meta-interprete per i predicati rule che compongono il nostro sistema/programma Prolog.
Ovviamente fino ad ora abbiamo considerato di rappresentare dei sistemi perfetti, in cui si può inferire in maniera certa su dei fatti/regole
cosa che difficilmente nella realtà avviene, per cui soprattutto per definire degli interpreti per l'apprendimento automatico, per questo
aggiungiamo ad ogni predicato/fatto un argomento numerico, tra 0.0 e 1.0,
indicante la probabilità che il fatto/predicato risulti verificato.\newline
Ad esempio modifichiamo il precedente esempio per considerare l'incertezza:
\begin{minted}{prolog}
solve_cf(true, 1) :- !.
solve_cf((A, B), C) :-
  !,
  solve_cf(A, CA),
  solve_cf(B, CB),
  minimum(CA, CB, C).
solve_cf(A, 1) :-
  builtin(A),
  !,
  call(A).
solve_cf(A, C) :-
  rule_cf(A, B, CR),
  solve_cf(B, CB),
  C is CR * CB.
\end{minted}
Il programma $solve_cf$ è un meta-interprete per stabilire se un goal G è vero e quanto siamo certi che sia vero.
